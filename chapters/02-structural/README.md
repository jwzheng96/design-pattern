# 第二部分：结构型模式 (Structural Patterns)

[← 返回目录](../../README.md)

---

## 概述

结构型模式关注**类和对象的组合**，通过组合形成更大的结构。这些模式可以帮助你：

- **简化设计**：提供简单的方式来识别实现类之间的关系
- **增加灵活性**：让你可以独立地改变结构的组成部分
- **解耦组件**：减少系统组件之间的依赖

### 结构型模式的两种类型

1. **类结构型模式**：使用继承来组合接口或实现（适配器）
2. **对象结构型模式**：使用对象组合来实现新功能（其他6种）

---

## 本部分包含的模式

| 模式 | 核心思想 | 适用场景 |
|-----|---------|---------|
| [适配器模式](adapter/README.md) | 转换接口 | 整合遗留代码、第三方库 |
| [桥接模式](bridge/README.md) | 分离抽象与实现 | 跨平台开发、多维度变化 |
| [组合模式](composite/README.md) | 树形结构 | 文件系统、UI组件、组织结构 |
| [装饰器模式](decorator/README.md) | 动态添加职责 | 流处理、中间件、增强功能 |
| [外观模式](facade/README.md) | 简化接口 | 库封装、子系统入口 |
| [享元模式](flyweight/README.md) | 共享细粒度对象 | 大量相似对象、游戏粒子 |
| [代理模式](proxy/README.md) | 控制访问 | 懒加载、权限控制、缓存 |

---

## 模式对比

```
┌────────────────────────────────────────────────────────────────────┐
│                       结构型模式对比                                │
├──────────────┬─────────────────────────────────────────────────────┤
│    模式      │                    关注点                           │
├──────────────┼─────────────────────────────────────────────────────┤
│   适配器     │  让不兼容的接口协同工作                               │
├──────────────┼─────────────────────────────────────────────────────┤
│    桥接      │  将抽象和实现分离，独立变化                           │
├──────────────┼─────────────────────────────────────────────────────┤
│    组合      │  统一处理单个对象和组合对象                           │
├──────────────┼─────────────────────────────────────────────────────┤
│   装饰器     │  动态添加职责，不改变对象结构                          │
├──────────────┼─────────────────────────────────────────────────────┤
│    外观      │  为子系统提供统一的高层接口                           │
├──────────────┼─────────────────────────────────────────────────────┤
│    享元      │  通过共享减少内存使用                                 │
├──────────────┼─────────────────────────────────────────────────────┤
│    代理      │  控制对对象的访问                                    │
└──────────────┴─────────────────────────────────────────────────────┘
```

---

## 如何选择？

```
遇到结构问题？
│
├─ 需要让不兼容的接口协作吗？
│   └─ 是 → 【适配器模式】
│
├─ 抽象和实现需要独立变化吗？
│   └─ 是 → 【桥接模式】
│
├─ 需要统一处理树形结构中的对象吗？
│   └─ 是 → 【组合模式】
│
├─ 需要动态添加对象功能吗？
│   └─ 是 → 【装饰器模式】
│
├─ 需要简化复杂子系统的访问吗？
│   └─ 是 → 【外观模式】
│
├─ 需要大量细粒度对象，且很多状态可以共享？
│   └─ 是 → 【享元模式】
│
└─ 需要控制对对象的访问（懒加载、权限等）？
    └─ 是 → 【代理模式】
```

---

## 开始学习

建议按以下顺序学习：

1. [适配器模式](adapter/README.md) - 最常用，容易理解
2. [装饰器模式](decorator/README.md) - 非常实用
3. [代理模式](proxy/README.md) - 应用广泛
4. [外观模式](facade/README.md) - 简单直观
5. [组合模式](composite/README.md) - 处理树形结构
6. [桥接模式](bridge/README.md) - 理解抽象与实现分离
7. [享元模式](flyweight/README.md) - 优化场景特定

---

[← 返回目录](../../README.md) | [开始学习：适配器模式 →](adapter/README.md)

